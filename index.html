<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zenith GTD - Task Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom Styles (Includes previous styles + new ones) */
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        body.overflow-hidden { overflow: hidden; }
        .sidebar-link.active { background-color: #e0f2fe; color: #0c4a6e; font-weight: 600; }
        .sidebar-link, button, input, select, textarea, label { transition: all 0.2s ease-in-out; }
        .task-list-container::-webkit-scrollbar, .log-list-container::-webkit-scrollbar { width: 6px; }
        .task-list-container::-webkit-scrollbar-track, .log-list-container::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .task-list-container::-webkit-scrollbar-thumb, .log-list-container::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 10px; }
        .task-list-container::-webkit-scrollbar-thumb:hover, .log-list-container::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
        .task-item.completed .task-title { text-decoration: line-through; color: #6b7280; }
        .modal { display: none; position: fixed; z-index: 50; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center; }
        .modal-content { background-color: #fff; margin: auto; padding: 1.5rem; border-radius: 0.5rem; width: 90%; max-width: 600px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); max-height: 90vh; display: flex; flex-direction: column; } /* Added max-height & flex */
        .modal-body { overflow-y: auto; } /* Allow modal content to scroll */
        .modal-close { color: #aaa; position: absolute; top: 0.5rem; right: 0.75rem; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 1; }
        .modal-close:hover, .modal-close:focus { color: #333; text-decoration: none; }
        .hidden { display: none !important; }
        #sidebar { transition: transform 0.3s ease-in-out; }
        #sidebar.mobile-visible { transform: translateX(0); }
        #sidebar-overlay { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.5); z-index: 30; opacity: 0; transition: opacity 0.3s ease-in-out; pointer-events: none; }
        #sidebar-overlay.visible { opacity: 1; pointer-events: auto; }
        .file-input-button { cursor: pointer; display: inline-flex; align-items: center; padding: 0.5rem 1rem; border-radius: 0.375rem; background-color: #10b981; color: white; font-weight: 500; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
        .file-input-button:hover { background-color: #059669; }
        input[type="file"].hidden-input { width: 0.1px; height: 0.1px; opacity: 0; overflow: hidden; position: absolute; z-index: -1; }
        @media (max-width: 480px) { #edit-task-form .flex.justify-end { flex-direction: column-reverse; align-items: stretch; } #edit-task-form .flex.justify-end button { width: 100%; } }
        .header-filter-container { display: flex; align-items: center; gap: 0.5rem; }
        .header-filter-container label { margin-right: 0.25rem; }
        .task-details-line { display: flex; flex-wrap: wrap; gap: 0.25rem; /* Space between badges */ line-height: 1.5; /* Adjust line height for wrapped badges */ }
        .task-details-line > span { margin-bottom: 0.25rem; /* Add bottom margin if badges wrap */ }
        .sortable-ghost { opacity: 0.4; background-color: #e0f2fe; }
        .sortable-chosen { cursor: grabbing; }
        .drag-handle { cursor: grab; color: #9ca3af; margin-right: 0.5rem; padding: 0 0.25rem; display: none; }
        .task-item:hover .drag-handle { display: inline-block; }
        .timer-active { color: #dc2626; /* Red */ animation: pulse 1.5s infinite ease-in-out; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .log-list-container { max-height: 250px; /* Limit height and allow scroll */ overflow-y: auto; margin-bottom: 1rem; }
    </style>
</head>
<body class="bg-gray-100">
    <div class="flex h-screen antialiased text-gray-800">
        <div id="sidebar-overlay" class=""></div>

        <aside id="sidebar" class="fixed inset-y-0 left-0 z-40 w-64 bg-white border-r border-gray-200 flex flex-col flex-shrink-0 transform -translate-x-full md:relative md:translate-x-0 md:flex">
            <div class="p-4 border-b border-gray-200 flex justify-between items-center">
                <h1 class="text-xl font-bold text-sky-700">Zenith GTD</h1>
                <button id="sidebar-close-button" class="md:hidden text-gray-500 hover:text-gray-700"> <i class="fas fa-times text-xl"></i> </button>
            </div>
            <nav class="flex-1 p-4 space-y-2 overflow-y-auto">
                <h2 class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">Capture & Process</h2>
                <a href="#" id="nav-inbox" class="sidebar-link flex items-center px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-md"> <i class="fas fa-inbox w-5 h-5 mr-3 text-gray-500"></i> Inbox </a>
                <h2 class="text-xs font-semibold text-gray-500 uppercase tracking-wider mt-4 mb-2">Organize</h2>
                <a href="#" id="nav-next" class="sidebar-link flex items-center px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-md"> <i class="fas fa-star w-5 h-5 mr-3 text-yellow-500"></i> Next Actions </a>
                <a href="#" id="nav-projects" class="sidebar-link flex items-center px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-md"> <i class="fas fa-tasks w-5 h-5 mr-3 text-blue-500"></i> Projects </a>
                <a href="#" id="nav-waiting" class="sidebar-link flex items-center px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-md"> <i class="fas fa-user-clock w-5 h-5 mr-3 text-orange-500"></i> Waiting For </a>
                <a href="#" id="nav-scheduled" class="sidebar-link flex items-center px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-md"> <i class="fas fa-calendar-alt w-5 h-5 mr-3 text-red-500"></i> Scheduled </a>
                <a href="#" id="nav-someday" class="sidebar-link flex items-center px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-md"> <i class="fas fa-cloud w-5 h-5 mr-3 text-purple-500"></i> Someday/Maybe </a>
                <a href="#" id="nav-reference" class="sidebar-link flex items-center px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-md"> <i class="fas fa-book w-5 h-5 mr-3 text-green-500"></i> Reference </a>
                <h2 class="text-xs font-semibold text-gray-500 uppercase tracking-wider mt-4 mb-2">Manage</h2>
                <a href="#" id="nav-contexts" class="sidebar-link flex items-center px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-md"> <i class="fas fa-at w-5 h-5 mr-3 text-gray-500"></i> Contexts </a>
                <a href="#" id="nav-areas" class="sidebar-link flex items-center px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-md"> <i class="fas fa-map-pin w-5 h-5 mr-3 text-gray-500"></i> Areas </a>
                <a href="#" id="nav-all-tasks" class="sidebar-link flex items-center px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-md"> <i class="fas fa-list-ul w-5 h-5 mr-3 text-gray-500"></i> All Tasks </a>
                <a href="#" id="nav-completed" class="sidebar-link flex items-center px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-md"> <i class="fas fa-check-circle w-5 h-5 mr-3 text-gray-500"></i> Completed </a>
            </nav>
            <div class="p-4 border-t border-gray-200 mt-auto space-y-3">
                <h2 class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">Data</h2>
                <button id="export-data-button" class="w-full flex items-center justify-center px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-1 text-sm"> <i class="fas fa-download w-4 h-4 mr-2"></i> Export Data </button>
                <label for="import-data-input" class="file-input-button w-full justify-center text-sm"> <i class="fas fa-upload w-4 h-4 mr-2"></i> Import Data </label>
                <input type="file" id="import-data-input" accept=".json" class="hidden-input">
            </div>
        </aside>

        <main class="flex-1 flex flex-col overflow-hidden">
            <header class="bg-white border-b border-gray-200 p-4 flex flex-wrap justify-between items-center flex-shrink-0 gap-2">
                <div class="flex items-center">
                    <button id="menu-toggle-button" class="md:hidden text-gray-600 hover:text-gray-800 focus:outline-none mr-3"> <i class="fas fa-bars text-xl"></i> </button>
                    <h2 id="current-view-title" class="text-lg font-semibold text-gray-800">Inbox</h2>
                </div>
                <div class="flex items-center gap-4">
                    <div id="context-filter-container" class="hidden header-filter-container">
                        <label for="context-filter-select" class="text-sm font-medium text-gray-700 hidden sm:inline">Context:</label>
                        <select id="context-filter-select" class="rounded-md border-gray-300 shadow-sm focus:border-sky-500 focus:ring-sky-500 text-sm py-1 px-2"> <option value="all">All</option> </select>
                    </div>
                    <div id="project-filter-container" class="hidden header-filter-container">
                        <label for="project-filter-select" class="text-sm font-medium text-gray-700 hidden sm:inline">Project:</label>
                        <select id="project-filter-select" class="rounded-md border-gray-300 shadow-sm focus:border-sky-500 focus:ring-sky-500 text-sm py-1 px-2"> <option value="all">All</option> </select>
                    </div>
                </div>
            </header>
            <div class="p-4 border-b border-gray-200 bg-gray-50 flex-shrink-0">
                <form id="add-task-form" class="flex gap-2">
                    <input type="text" id="new-task-title" placeholder="Capture a new task..." class="flex-grow px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-transparent" required>
                    <button type="submit" class="px-4 py-2 bg-sky-600 text-white rounded-md hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-1 flex-shrink-0"> <i class="fas fa-plus md:mr-1"></i> <span class="hidden md:inline">Add</span> </button>
                </form>
                <form id="add-management-item-form" class="hidden flex gap-2">
                    <input type="text" id="new-management-item-name" placeholder="Add new..." class="flex-grow px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-transparent" required>
                    <button type="submit" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-1 flex-shrink-0"> <i class="fas fa-plus md:mr-1"></i> <span class="hidden md:inline">Add Item</span> </button>
                </form>
            </div>
            <div id="task-list-container" class="flex-1 overflow-y-auto p-4 task-list-container">
                <p id="empty-state-message" class="text-center text-gray-500 mt-10">No tasks here yet!</p>
                <ul id="task-list" class="space-y-3"></ul> <ul id="management-item-list" class="space-y-2 hidden"></ul> </div>
        </main>

        <div id="task-modal" class="modal">
            <div class="modal-content relative">
                <span class="modal-close">&times;</span>
                <h3 id="modal-title" class="text-xl font-semibold mb-6 flex-shrink-0">Process Task</h3>
                <div class="modal-body flex-grow">
                    <form id="edit-task-form">
                        <input type="hidden" id="edit-task-id">
                        <div class="mb-4"> <label for="edit-task-title" class="block text-sm font-medium text-gray-700 mb-1">Title</label> <input type="text" id="edit-task-title" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-transparent" required> </div>
                        <div class="mb-4"> <label for="edit-task-notes" class="block text-sm font-medium text-gray-700 mb-1">Notes</label> <textarea id="edit-task-notes" rows="3" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-transparent"></textarea> </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div> <label for="edit-task-status" class="block text-sm font-medium text-gray-700 mb-1">Status</label> <select id="edit-task-status" class="w-full px-3 py-2 border border-gray-300 rounded-md bg-white focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-transparent"> <option value="inbox">Inbox</option> <option value="next">Next Action</option> <option value="project_task">Project Task</option> <option value="waiting">Waiting For</option> <option value="scheduled">Scheduled</option> <option value="someday">Someday/Maybe</option> <option value="reference">Reference</option> <option value="completed">Completed</option> </select> </div>
                            <div> <label for="edit-task-project" class="block text-sm font-medium text-gray-700 mb-1">Project</label> <select id="edit-task-project" class="w-full px-3 py-2 border border-gray-300 rounded-md bg-white focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-transparent"> <option value="">None</option> </select> </div>
                            <div> <label for="edit-task-context" class="block text-sm font-medium text-gray-700 mb-1">Context</label> <select id="edit-task-context" class="w-full px-3 py-2 border border-gray-300 rounded-md bg-white focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-transparent"> <option value="">None</option> </select> </div>
                            <div> <label for="edit-task-area" class="block text-sm font-medium text-gray-700 mb-1">Area</label> <select id="edit-task-area" class="w-full px-3 py-2 border border-gray-300 rounded-md bg-white focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-transparent"> <option value="">None</option> </select> </div>
                            <div> <label for="edit-task-due-date" class="block text-sm font-medium text-gray-700 mb-1">Due Date</label> <input type="date" id="edit-task-due-date" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-transparent"> </div>
                        </div>
                        <div class="flex justify-end gap-3 mt-6 flex-shrink-0">
                            <button type="button" id="delete-task-button" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-1 hidden"> <i class="fas fa-trash-alt mr-1"></i> Delete </button>
                            <button type="submit" class="px-4 py-2 bg-sky-600 text-white rounded-md hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-1"> <i class="fas fa-save mr-1"></i> Save Changes </button>
                            <button type="button" class="modal-cancel-button px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-1"> Cancel </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <div id="time-log-modal" class="modal">
            <div class="modal-content relative">
                <span class="modal-close">&times;</span>
                <h3 id="time-log-modal-title" class="text-xl font-semibold mb-4 flex-shrink-0">Time Logs for Task</h3>
                <input type="hidden" id="time-log-task-id">

                <div class="mb-4 p-3 bg-gray-50 rounded-md border border-gray-200 flex items-center justify-between flex-shrink-0">
                    <span class="text-sm font-medium text-gray-700">Track Time:</span>
                    <div>
                        <button id="start-timer-button" class="px-3 py-1 bg-green-500 text-white rounded-md hover:bg-green-600 text-sm focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-offset-1">
                            <i class="fas fa-play mr-1"></i> Start
                        </button>
                        <button id="stop-timer-button" class="px-3 py-1 bg-red-500 text-white rounded-md hover:bg-red-600 text-sm focus:outline-none focus:ring-2 focus:ring-red-400 focus:ring-offset-1 hidden">
                            <i class="fas fa-stop mr-1"></i> Stop
                        </button>
                    </div>
                </div>

                <div class="modal-body flex-grow mb-4">
                    <h4 class="text-md font-semibold text-gray-700 mb-2">Logged Entries (<span id="total-logged-time">0h 0m</span>)</h4>
                    <div id="log-list-container" class="log-list-container border border-gray-200 rounded-md p-2 bg-white">
                        <ul id="time-log-list" class="space-y-2">
                            </ul>
                        <p id="no-logs-message" class="text-center text-gray-500 py-4 hidden">No time logged yet.</p>
                    </div>
                </div>

                <div class="flex-shrink-0">
                    <h4 class="text-md font-semibold text-gray-700 mb-2">Add Manual Log Entry</h4>
                    <form id="add-manual-log-form" class="p-3 bg-gray-50 rounded-md border border-gray-200 space-y-3">
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                            <div>
                                <label for="manual-log-date" class="block text-sm font-medium text-gray-600 mb-1">Date</label>
                                <input type="date" id="manual-log-date" class="w-full px-2 py-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-sky-500" required>
                            </div>
                            <div>
                                <label for="manual-log-duration" class="block text-sm font-medium text-gray-600 mb-1">Duration (HH:MM)</label>
                                <input type="text" id="manual-log-duration" placeholder="e.g., 01:30" pattern="[0-9]{1,2}:[0-5][0-9]" class="w-full px-2 py-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-sky-500" required>
                            </div>
                        </div>
                        <div>
                            <label for="manual-log-description" class="block text-sm font-medium text-gray-600 mb-1">Description (Optional)</label>
                            <input type="text" id="manual-log-description" placeholder="What did you work on?" class="w-full px-2 py-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-sky-500">
                        </div>
                        <div class="text-right">
                            <button type="submit" class="px-4 py-1.5 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-1">
                                <i class="fas fa-plus mr-1"></i> Add Entry
                            </button>
                        </div>
                    </form>
                </div>

                <div class="mt-4 text-right flex-shrink-0">
                     <button type="button" class="modal-cancel-button px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-1"> Close </button>
                 </div>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            // (Existing elements...)
            const addTaskForm = document.getElementById('add-task-form');
            const newTaskTitleInput = document.getElementById('new-task-title');
            const taskListUl = document.getElementById('task-list');
            const managementItemListUl = document.getElementById('management-item-list');
            const currentViewTitle = document.getElementById('current-view-title');
            const sidebarLinks = document.querySelectorAll('.sidebar-link');
            const emptyStateMessage = document.getElementById('empty-state-message');
            const addManagementItemForm = document.getElementById('add-management-item-form');
            const newManagementItemNameInput = document.getElementById('new-management-item-name');
            const taskModal = document.getElementById('task-modal');
            const modalTitle = document.getElementById('modal-title');
            const editTaskForm = document.getElementById('edit-task-form');
            const editTaskId = document.getElementById('edit-task-id');
            const editTaskTitle = document.getElementById('edit-task-title');
            const editTaskNotes = document.getElementById('edit-task-notes');
            const editTaskStatus = document.getElementById('edit-task-status');
            const editTaskProject = document.getElementById('edit-task-project');
            const editTaskContext = document.getElementById('edit-task-context');
            const editTaskArea = document.getElementById('edit-task-area');
            const editTaskDueDate = document.getElementById('edit-task-due-date');
            const deleteTaskButton = document.getElementById('delete-task-button');
            const closeModalButton = taskModal.querySelector('.modal-close');
            const cancelModalButton = taskModal.querySelector('.modal-cancel-button');
            const exportDataButton = document.getElementById('export-data-button');
            const importDataInput = document.getElementById('import-data-input');
            const sidebar = document.getElementById('sidebar');
            const sidebarOverlay = document.getElementById('sidebar-overlay');
            const menuToggleButton = document.getElementById('menu-toggle-button');
            const sidebarCloseButton = document.getElementById('sidebar-close-button');
            const contextFilterContainer = document.getElementById('context-filter-container');
            const contextFilterSelect = document.getElementById('context-filter-select');
            const projectFilterContainer = document.getElementById('project-filter-container');
            const projectFilterSelect = document.getElementById('project-filter-select');

            // Time Log Modal Elements
            const timeLogModal = document.getElementById('time-log-modal');
            const timeLogModalTitle = document.getElementById('time-log-modal-title');
            const timeLogTaskId = document.getElementById('time-log-task-id');
            const startTimerButton = document.getElementById('start-timer-button');
            const stopTimerButton = document.getElementById('stop-timer-button');
            const totalLoggedTimeSpan = document.getElementById('total-logged-time');
            const timeLogListUl = document.getElementById('time-log-list');
            const noLogsMessage = document.getElementById('no-logs-message');
            const addManualLogForm = document.getElementById('add-manual-log-form');
            const manualLogDateInput = document.getElementById('manual-log-date');
            const manualLogDurationInput = document.getElementById('manual-log-duration');
            const manualLogDescriptionInput = document.getElementById('manual-log-description');
            const timeLogModalCloseButton = timeLogModal.querySelector('.modal-close');
            const timeLogModalCancelButton = timeLogModal.querySelector('.modal-cancel-button');


            // --- State ---
            let currentView = 'inbox'; // Default view
            let currentManagementView = null; // Tracks if viewing Projects, Contexts, or Areas
            let currentContextFilter = 'all'; // Filter for Next Actions view
            let currentProjectFilter = 'all'; // Filter for All Tasks view
            let sortableInstance = null; // SortableJS instance
            let activeTimerInterval = null; // Interval ID for updating active timer display
            let activeTimerTaskId = null; // ID of the task currently being timed

            // --- Data Storage (localStorage) ---
             // Function to retrieve data from localStorage, providing default values and error handling.
             const getData = (key, defaultValue = []) => {
                 const data = localStorage.getItem(key);
                 try {
                     const parsedData = data ? JSON.parse(data) : defaultValue;
                     // Data Migration/Validation: Ensure tasks have IDs and timeLogs array.
                     if (key === 'gtdTasks') {
                         parsedData.forEach(task => {
                             if (!task.id) task.id = generateId();
                             if (!Array.isArray(task.timeLogs)) task.timeLogs = []; // Add timeLogs if missing
                             // Ensure logs have IDs and isActive flag
                             task.timeLogs.forEach(log => {
                                 if (!log.id) log.id = generateId();
                                 if (typeof log.isActive === 'undefined') log.isActive = false; // Add isActive if missing
                             });
                         });
                     }
                     // Ensure management items have IDs.
                     if (['gtdProjects', 'gtdContexts', 'gtdAreas'].includes(key)) {
                         parsedData.forEach(item => { if (!item.id) item.id = generateId(); });
                     }
                     return Array.isArray(parsedData) ? parsedData : defaultValue; // Ensure it returns an array
                 } catch (error) {
                     console.error(`Error parsing localStorage key "${key}":`, error);
                     // Optional: Clear corrupted key (use with caution)
                     // localStorage.removeItem(key);
                     return defaultValue;
                 }
             };

             // Function to save data to localStorage with error handling.
             const saveData = (key, data) => {
                 try {
                     localStorage.setItem(key, JSON.stringify(data));
                 } catch (error) {
                     console.error(`Error saving data to localStorage key "${key}":`, error);
                     alert('Error saving data. Local storage might be full or inaccessible.');
                 }
             };

            // Load initial data from localStorage
            let tasks = getData('gtdTasks');
            let projects = getData('gtdProjects');
            let contexts = getData('gtdContexts');
            let areas = getData('gtdAreas');

            // --- Utility Functions ---
            // Generates a unique ID string.
            const generateId = () => `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Formats total seconds into a "Xh Ym" string.
            const formatDuration = (totalSeconds) => {
                if (isNaN(totalSeconds) || totalSeconds < 0) {
                    return '0h 0m';
                }
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                // const seconds = totalSeconds % 60; // Optionally include seconds
                return `${hours}h ${minutes}m`;
            };

            // Parses a "HH:MM" duration string into total seconds. Returns 0 if invalid.
            const parseDurationHHMM = (hhmm) => {
                if (!hhmm || typeof hhmm !== 'string') return 0;
                const parts = hhmm.split(':');
                if (parts.length !== 2) return 0;
                const hours = parseInt(parts[0], 10);
                const minutes = parseInt(parts[1], 10);
                // Validate parsed numbers
                if (isNaN(hours) || isNaN(minutes) || minutes < 0 || minutes >= 60 || hours < 0) {
                    return 0; // Invalid format
                }
                return (hours * 3600) + (minutes * 60);
            };

            // Finds a task by its ID.
            const getTaskById = (id) => tasks.find(task => task.id === id);

            // --- Core Task Functions (addTask, updateTask, deleteTask) ---
            // Adds a new task to the list.
            const addTask = (title) => {
                const trimmedTitle = title.trim();
                if (!trimmedTitle) return; // Don't add empty tasks
                const newTask = {
                    id: generateId(),
                    title: trimmedTitle,
                    notes: '',
                    status: 'inbox', // Default status
                    projectId: null,
                    contextId: null,
                    areaId: null,
                    dueDate: null,
                    createdAt: new Date().toISOString(),
                    completedAt: null, // Timestamp for completion
                    timeLogs: [] // Initialize time logs array
                };
                tasks.push(newTask); // Add to the beginning or end based on preference
                saveData('gtdTasks', tasks);
                newTaskTitleInput.value = ''; // Clear input field
                render(); // Update the UI
            };

            // Updates an existing task with new data.
            const updateTask = (id, updates) => {
                let taskUpdated = false;
                tasks = tasks.map(task => {
                    if (task.id === id) {
                        taskUpdated = true;
                        // Handle setting/clearing the completion timestamp
                        if ('status' in updates) {
                            if (updates.status === 'completed' && task.status !== 'completed') {
                                updates.completedAt = new Date().toISOString();
                            } else if (updates.status !== 'completed' && task.status === 'completed') {
                                updates.completedAt = null;
                            }
                        }
                        // Ensure empty selections in the modal are saved as null
                        if ('projectId' in updates) updates.projectId = updates.projectId || null;
                        if ('contextId' in updates) updates.contextId = updates.contextId || null;
                        if ('areaId' in updates) updates.areaId = updates.areaId || null;
                        if ('dueDate' in updates) updates.dueDate = updates.dueDate || null;
                        // Ensure timeLogs array exists (migration)
                        if (!Array.isArray(task.timeLogs)) task.timeLogs = [];

                        return { ...task, ...updates }; // Merge updates with existing task data
                    }
                    return task;
                });

                if (taskUpdated) {
                    saveData('gtdTasks', tasks);
                    render(); // Re-render to reflect changes
                } else {
                    console.error("Task not found for update:", id);
                }
            };

            // Deletes a task after confirmation.
            const deleteTask = (id) => {
                 if (confirm('Are you sure you want to delete this task and all its time logs? This action cannot be undone.')) {
                     const initialLength = tasks.length;
                     tasks = tasks.filter(task => task.id !== id);
                     if (tasks.length < initialLength) {
                         saveData('gtdTasks', tasks);
                         closeModal(); // Close edit modal if it was open for this task
                         closeTimeLogModal(); // Close time log modal if it was open
                         render(); // Update the UI
                     }
                 }
            };

            // --- Management Item Functions (addManagementItem, deleteManagementItem) ---
            // Adds a new Project, Context, or Area.
            const addManagementItem = (name) => {
                const trimmedName = name.trim();
                if (!trimmedName || !currentManagementView) return; // Need name and view type

                const newItem = { id: generateId(), name: trimmedName };
                let dataArray, storageKey;

                // Determine which list to add to based on the current management view
                switch (currentManagementView) {
                    case 'projects': dataArray = projects; storageKey = 'gtdProjects'; break;
                    case 'contexts': dataArray = contexts; storageKey = 'gtdContexts'; break;
                    case 'areas':    dataArray = areas;    storageKey = 'gtdAreas'; break;
                    default: return; // Should not happen
                }

                // Check for duplicates (case-insensitive) before adding
                if (dataArray.some(item => item.name.toLowerCase() === trimmedName.toLowerCase())) {
                    alert(`${currentManagementView.slice(0, -1)} "${trimmedName}" already exists.`);
                    return;
                }

                dataArray.push(newItem);
                saveData(storageKey, dataArray);
                newManagementItemNameInput.value = ''; // Clear input
                render(); // Update UI
            };

            // Deletes a Project, Context, or Area after confirmation.
            const deleteManagementItem = (id, type) => {
                 if (!confirm(`Are you sure you want to delete this ${type}? This will remove it from all associated tasks.`)) return;

                 let dataArray, storageKey, taskField;
                 // Determine which list and task field to update
                 switch (type) {
                     case 'project': dataArray = projects; storageKey = 'gtdProjects'; taskField = 'projectId'; break;
                     case 'context': dataArray = contexts; storageKey = 'gtdContexts'; taskField = 'contextId'; break;
                     case 'area':    dataArray = areas;    storageKey = 'gtdAreas';    taskField = 'areaId'; break;
                     default: return;
                 }

                 const initialLength = dataArray.length;
                 const updatedArray = dataArray.filter(item => item.id !== id);

                 // Proceed only if an item was actually removed
                 if (updatedArray.length < initialLength) {
                     // Update the specific management item list in memory
                     if (type === 'project') projects = updatedArray;
                     if (type === 'context') contexts = updatedArray;
                     if (type === 'area')    areas = updatedArray;
                     saveData(storageKey, updatedArray); // Save the updated list

                     // Remove the reference from all tasks that used this item
                     let tasksUpdated = false;
                     tasks = tasks.map(task => {
                         if (task[taskField] === id) {
                             tasksUpdated = true;
                             return { ...task, [taskField]: null }; // Set the field to null
                         }
                         return task;
                     });

                     // Save tasks if any were updated
                     if (tasksUpdated) {
                         saveData('gtdTasks', tasks);
                     }
                     render(); // Re-render everything to reflect changes
                 }
            };

            // --- Time Logging Functions ---
            // Calculates the total logged time for a task in seconds.
            const calculateTotalTime = (taskId) => {
                const task = getTaskById(taskId);
                if (!task || !task.timeLogs) return 0;
                // Sum the duration of all logs for the task
                return task.timeLogs.reduce((total, log) => total + (log.duration || 0), 0);
            };

            // Finds the currently active time log entry for a task, if any.
            const getActiveLog = (taskId) => {
                 const task = getTaskById(taskId);
                 // Find the log entry marked as active
                 return task?.timeLogs?.find(log => log.isActive);
            };

            // Starts a timer for a specific task.
            const startTimer = (taskId) => {
                 console.log("Attempting to start timer for task:", taskId);
                 // Stop any other active timer first to prevent multiple timers running.
                 if (activeTimerTaskId && activeTimerTaskId !== taskId) {
                     stopTimer(activeTimerTaskId, false); // Stop without immediate re-render
                 }
                 // Prevent starting if a timer is already active for *this* task.
                 if (getActiveLog(taskId)) {
                     console.warn("Timer already active for task:", taskId);
                     return;
                 }

                 const task = getTaskById(taskId);
                 if (!task) return; // Task must exist

                 // Create a new log entry for the active timer
                 const newLog = {
                     id: generateId(),
                     startTime: new Date().toISOString(),
                     endTime: null, // Will be set when stopped
                     duration: 0, // Will be calculated when stopped
                     description: 'Active Timer', // Placeholder description
                     manual: false, // Indicates it's from the timer
                     isActive: true // Mark this log as the currently active one
                 };

                 task.timeLogs.push(newLog);
                 activeTimerTaskId = taskId; // Track which task's timer is globally active
                 saveData('gtdTasks', tasks);
                 renderTimeLogModal(taskId); // Update the time log modal UI immediately
                 render(); // Update the main task list UI (for the timer icon)
                 startActiveTimerUpdates(taskId); // Start the interval to update the display
                 console.log("Timer started for task:", taskId);
            };

            // Stops the active timer for a specific task.
            const stopTimer = (taskId, shouldRender = true) => {
                 console.log("Attempting to stop timer for task:", taskId);
                 const task = getTaskById(taskId);
                 const activeLog = getActiveLog(taskId); // Find the log entry marked as active

                 if (!task || !activeLog) {
                     console.warn("No active timer found to stop for task:", taskId);
                     // Clear global state if it's somehow out of sync
                     if (activeTimerTaskId === taskId) {
                         activeTimerTaskId = null;
                         stopActiveTimerUpdates();
                     }
                     return;
                 }

                 // Calculate duration
                 const startTime = new Date(activeLog.startTime);
                 const endTime = new Date();
                 const durationSeconds = Math.round((endTime.getTime() - startTime.getTime()) / 1000);

                 // Update the log entry with end time and calculated duration
                 activeLog.endTime = endTime.toISOString();
                 activeLog.duration = durationSeconds > 0 ? durationSeconds : 0; // Ensure duration is not negative
                 activeLog.isActive = false; // Mark as no longer active
                 // Clear the placeholder description if it wasn't changed
                 if (activeLog.description === 'Active Timer') {
                     activeLog.description = '';
                 }

                 activeTimerTaskId = null; // Clear the globally active timer tracker
                 stopActiveTimerUpdates(); // Stop the UI update interval

                 saveData('gtdTasks', tasks);
                 // Optionally re-render UI (useful unless called internally before another render)
                 if (shouldRender) {
                     renderTimeLogModal(taskId); // Update modal UI
                     render(); // Update main list UI
                 }
                 console.log("Timer stopped for task:", taskId);
            };

            // Adds a manual time log entry to a task.
            const addManualLog = (taskId, dateStr, durationStr, description) => {
                const task = getTaskById(taskId);
                if (!task) return false; // Task must exist

                const durationSeconds = parseDurationHHMM(durationStr);
                // Validate duration
                if (durationSeconds <= 0) {
                    alert("Invalid duration format. Please use HH:MM (e.g., 01:30) and ensure it's greater than 0.");
                    return false;
                }
                // Validate date
                if (!dateStr) {
                    alert("Please select a date for the manual entry.");
                    return false;
                }

                // Create the manual log entry
                const newLog = {
                    id: generateId(),
                    // Store the selected date as the 'startTime' for sorting/display purposes
                    startTime: new Date(dateStr + 'T00:00:00').toISOString(),
                    endTime: null, // Manual entries don't have a specific end time
                    duration: durationSeconds,
                    description: description.trim() || 'Manual Entry', // Default description
                    manual: true, // Mark as manually added
                    isActive: false // Manual entries are never 'active'
                };

                task.timeLogs.push(newLog);
                saveData('gtdTasks', tasks);
                renderTimeLogModal(taskId); // Update the modal list
                render(); // Update the main task list (e.g., total time badge)
                return true; // Indicate success
            };

            // Deletes a specific time log entry from a task.
            const deleteLog = (taskId, logId) => {
                const task = getTaskById(taskId);
                if (!task) return;

                const initialLogCount = task.timeLogs.length;
                // Filter out the log entry with the matching ID
                task.timeLogs = task.timeLogs.filter(log => log.id !== logId);

                // Save and re-render if a log was actually deleted
                if (task.timeLogs.length < initialLogCount) {
                    saveData('gtdTasks', tasks);
                    renderTimeLogModal(taskId); // Update modal list
                    render(); // Update main task list
                }
            };

            // --- Active Timer UI Update Functions ---
            // Starts an interval to update the displayed time for the active timer.
            const startActiveTimerUpdates = (taskId) => {
                stopActiveTimerUpdates(); // Clear any existing interval first
                activeTimerInterval = setInterval(() => {
                    const activeLog = getActiveLog(taskId);
                    if (!activeLog) {
                        stopActiveTimerUpdates(); // Stop if the log somehow disappeared
                        return;
                    }
                    // Update total time display in the modal *if* it's open for the active task
                    if (!timeLogModal.classList.contains('hidden') && timeLogTaskId.value === taskId) {
                        const currentDuration = Math.round((new Date().getTime() - new Date(activeLog.startTime).getTime()) / 1000);
                        // Recalculate total time including the *current* duration of the active log
                        const totalSeconds = calculateTotalTime(taskId) - (activeLog.duration || 0) + currentDuration;
                         totalLoggedTimeSpan.textContent = formatDuration(totalSeconds);
                    }
                    // The pulsing icon in the main task list is handled by the `renderTaskItem` function checking `getActiveLog`.
                    // A full re-render every second is too inefficient, so we only update the modal here.
                }, 1000); // Update every second
            };

            // Clears the active timer UI update interval.
            const stopActiveTimerUpdates = () => {
                if (activeTimerInterval) {
                    clearInterval(activeTimerInterval);
                    activeTimerInterval = null;
                }
            };


            // --- Rendering Functions ---
            // Generates the HTML for a status badge based on the task status.
            const getStatusBadge = (status) => {
                let badgeClass = ''; let badgeText = '';
                switch (status) {
                    case 'inbox': badgeClass = 'bg-gray-200 text-gray-700'; badgeText = 'Inbox'; break;
                    case 'next': badgeClass = 'bg-yellow-100 text-yellow-700'; badgeText = 'Next'; break;
                    case 'project_task': badgeClass = 'bg-blue-100 text-blue-700'; badgeText = 'Project Task'; break;
                    case 'waiting': badgeClass = 'bg-orange-100 text-orange-700'; badgeText = 'Waiting'; break;
                    case 'scheduled': badgeClass = 'bg-purple-100 text-purple-700'; badgeText = 'Scheduled'; break;
                    case 'someday': badgeClass = 'bg-teal-100 text-teal-700'; badgeText = 'Someday'; break;
                    case 'reference': badgeClass = 'bg-green-100 text-green-700'; badgeText = 'Reference'; break;
                    case 'completed': return ''; // Completed tasks don't show a status badge in the list
                    default: return ''; // Unknown status
                }
                return `<span class="text-xs ${badgeClass} px-2 py-0.5 rounded-full whitespace-nowrap">${badgeText}</span>`;
            };

            // Populates a <select> dropdown element with options.
            const populateSelect = (selectElement, items, defaultOptionText = 'None', valueIfNone = '', addAllOption = false, allOptionValue = 'all', allOptionText = 'All') => {
                if (!selectElement) return;
                selectElement.innerHTML = ''; // Clear existing options

                // Add an "All" option if requested (for filters)
                if (addAllOption) {
                    const allOption = document.createElement('option');
                    allOption.value = allOptionValue;
                    allOption.textContent = allOptionText;
                    selectElement.appendChild(allOption);
                }

                // Add a default/none option if requested
                if (defaultOptionText) {
                    const defaultOption = document.createElement('option');
                    defaultOption.value = valueIfNone;
                    defaultOption.textContent = defaultOptionText;
                    selectElement.appendChild(defaultOption);
                }

                // Add options for each item, sorted alphabetically by name
                items.sort((a, b) => a.name.localeCompare(b.name)).forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.id;
                    option.textContent = item.name;
                    selectElement.appendChild(option);
                });
            };

            // Renders a single task item (<li> element).
            const renderTaskItem = (task) => {
                const li = document.createElement('li');
                // Ensure task has an ID (migration/safety check)
                if (!task.id) {
                    console.warn("Task missing ID during render:", task);
                    task.id = generateId();
                }
                // Apply base classes and 'completed' class if applicable
                 li.className = `task-item bg-white p-3 rounded-md shadow-sm border border-gray-200 flex items-center justify-between gap-2 ${task.status === 'completed' ? 'completed' : ''}`;
                li.dataset.taskId = task.id; // Store task ID for event listeners

                // Determine if the task is actionable (can be checked off)
                // Note: We allow unchecking completed tasks from the completed view.
                const isActionable = ['next', 'project_task', 'scheduled', 'waiting', 'completed'].includes(task.status);

                // Generate checkbox HTML (or placeholder if not actionable)
                const checkboxHtml = isActionable
                    ? `<input type="checkbox" class="task-complete-checkbox h-5 w-5 text-sky-600 border-gray-300 rounded focus:ring-sky-500 cursor-pointer flex-shrink-0" ${task.status === 'completed' ? 'checked' : ''}>`
                    : `<div class="w-5 h-5 flex-shrink-0"></div>`; // Placeholder for non-actionable items like 'inbox'

                // --- Generate Details HTML (Badges) ---
                let statusBadgeHtml = getStatusBadge(task.status); // Get status badge (empty for completed)
                let projectBadgeHtml = '';
                let contextBadgeHtml = '';
                let dateBadgeHtml = '';
                let timeBadgeHtml = ''; // For total logged time
                let completedDateHtml = ''; // *** NEW: For completed date ***

                // Find associated project/context names
                const project = task.projectId ? projects.find(p => p.id === task.projectId) : null;
                const context = task.contextId ? contexts.find(c => c.id === task.contextId) : null;
                const totalSeconds = calculateTotalTime(task.id); // Get total logged time
                const isActive = !!getActiveLog(task.id); // Check if timer is currently running

                // Create badges if data exists
                if (project) projectBadgeHtml = `<span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full whitespace-nowrap">${project.name}</span>`;
                if (context) contextBadgeHtml = `<span class="text-xs bg-gray-100 text-gray-700 px-2 py-0.5 rounded-full whitespace-nowrap">@${context.name}</span>`;
                if (task.dueDate) {
                    try { // Format due date safely
                        const date = new Date(task.dueDate);
                        const timezoneOffset = date.getTimezoneOffset() * 60000; // Adjust for local timezone display
                        const localDate = new Date(date.getTime() + timezoneOffset);
                        const formattedDate = localDate.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
                        dateBadgeHtml = `<span class="text-xs bg-red-100 text-red-700 px-2 py-0.5 rounded-full whitespace-nowrap"><i class="far fa-calendar-alt mr-1"></i>${formattedDate}</span>`;
                    } catch (e) { console.error("Error formatting due date:", task.dueDate, e); }
                }
                 // *** NEW: Add completed date badge if task is completed ***
                 if (task.status === 'completed' && task.completedAt) {
                     try {
                         const completedDate = new Date(task.completedAt);
                         const formattedCompletedDate = completedDate.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
                         completedDateHtml = `<span class="text-xs bg-green-100 text-green-700 px-2 py-0.5 rounded-full whitespace-nowrap"><i class="far fa-check-circle mr-1"></i>${formattedCompletedDate}</span>`;
                     } catch (e) { console.error("Error formatting completed date:", task.completedAt, e); }
                 }
                // Add time badge if time is logged OR the timer is currently active
                if (totalSeconds > 0 || isActive) {
                    const timeText = formatDuration(totalSeconds);
                    // Apply pulsing style if timer is active
                    const activeClass = isActive ? 'timer-active bg-red-100 text-red-700' : 'bg-indigo-100 text-indigo-700';
                    timeBadgeHtml = `<span class="task-total-time text-xs ${activeClass} px-2 py-0.5 rounded-full whitespace-nowrap"><i class="far fa-clock mr-1"></i>${timeText}</span>`;
                }

                // Combine all detail badges into a single string
                const detailsHtml = [statusBadgeHtml, completedDateHtml, projectBadgeHtml, contextBadgeHtml, dateBadgeHtml, timeBadgeHtml].filter(Boolean).join('');
                // HTML for the drag handle (used by SortableJS)
                const dragHandleHtml = `<span class="drag-handle"><i class="fas fa-grip-vertical"></i></span>`;

                // Construct the inner HTML of the list item
                li.innerHTML = `
                    <div class="flex items-center gap-3 flex-grow min-w-0">
                        ${dragHandleHtml} ${checkboxHtml} <div class="flex-grow overflow-hidden">
                            <span class="task-title text-gray-800 cursor-pointer hover:text-sky-600 truncate block" title="${task.title}">${task.title}</span>
                            <div class="text-xs text-gray-500 mt-1 task-details-line">
                                ${detailsHtml || '&nbsp;'} </div>
                        </div>
                    </div>
                    <div class="flex items-center flex-shrink-0 gap-1">
                        <button class="time-log-button text-gray-400 hover:text-indigo-600 px-2 py-1 rounded" title="View Time Logs">
                            <i class="fas fa-history"></i>
                        </button>
                        <button class="edit-task-button text-gray-400 hover:text-sky-600 px-2 py-1 rounded" title="Edit Task">
                            <i class="fas fa-pencil-alt"></i>
                        </button>
                    </div>
                `;

                // --- Add Event Listeners to the new elements ---
                // Edit button opens the task edit modal
                li.querySelector('.edit-task-button').addEventListener('click', (e) => { e.stopPropagation(); openModal(task.id); });
                // Clicking the task title also opens the edit modal
                li.querySelector('.task-title').addEventListener('click', () => openModal(task.id));
                 // Time log button opens the time log modal
                 li.querySelector('.time-log-button').addEventListener('click', (e) => { e.stopPropagation(); openTimeLogModal(task.id); });

                // Checkbox listener (only if checkbox exists)
                const checkbox = li.querySelector('.task-complete-checkbox');
                if (checkbox) {
                    checkbox.addEventListener('change', (e) => {
                        // Determine the status to revert to when unchecking
                        // If it was a project task, keep it as project task, otherwise default to 'next'
                        // This could be enhanced to remember the *exact* previous state if needed.
                        const previousStatus = task.status === 'project_task' ? 'project_task' : 'next';
                        // Set new status based on checkbox state
                        const newStatus = e.target.checked ? 'completed' : previousStatus;
                        updateTask(task.id, { status: newStatus });
                    });
                }

                return li; // Return the fully constructed list item element
            };

            // Renders a single management item (Project, Context, Area).
            const renderManagementItem = (item, type) => {
                const li = document.createElement('li');
                li.className = 'bg-white p-3 rounded-md shadow-sm border border-gray-200 flex items-center justify-between gap-2';
                li.dataset.itemId = item.id; // Store ID for deletion
                li.dataset.itemType = type; // Store type for deletion message
                li.innerHTML = `
                    <span class="text-gray-800 flex-grow truncate" title="${item.name}">${item.name}</span>
                    <button class="delete-item-button text-red-400 hover:text-red-600 px-2 py-1 rounded flex-shrink-0" title="Delete ${type}">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                `;
                // Add listener to the delete button
                li.querySelector('.delete-item-button').addEventListener('click', () => deleteManagementItem(item.id, type));
                return li;
            };

            // --- Sorting Function ---
            // Initializes or destroys the SortableJS instance for the task list.
            const initSortable = () => {
                 // Destroy existing instance if it exists
                 if (sortableInstance) {
                     sortableInstance.destroy();
                     sortableInstance = null;
                 }

                 // Only initialize if the task list is visible and not empty
                 // Sorting is only enabled for non-completed, non-management views currently.
                 const canSort = !taskListUl.classList.contains('hidden') &&
                                  taskListUl.children.length > 0 &&
                                  currentView !== 'completed' && // Don't sort completed view
                                  !currentManagementView;         // Don't sort management views

                 if (canSort) {
                     // Show drag handles
                     taskListUl.querySelectorAll('.task-item .drag-handle').forEach(handle => handle.style.display = 'inline-block');

                     // Create new SortableJS instance
                     sortableInstance = new Sortable(taskListUl, {
                         animation: 150, // Animation speed
                         ghostClass: 'sortable-ghost', // Class for the placeholder
                         chosenClass: 'sortable-chosen', // Class for the item being dragged
                         handle: '.drag-handle', // Specify the drag handle element
                         onEnd: (evt) => { // Function called when dragging ends
                             // Get the new order of task IDs from the DOM
                             const orderedTaskIds = Array.from(evt.to.children).map(li => li.dataset.taskId);
                             // Create a map for quick lookup of tasks by ID
                             const taskMap = new Map(tasks.map(task => [task.id, task]));
                             // Create the reordered array based on the new DOM order
                             const reorderedTasks = orderedTaskIds.map(id => taskMap.get(id)).filter(Boolean);

                             // Add back any tasks that were *not* in the current view (e.g., completed tasks)
                             // to maintain the full task list integrity.
                             const currentViewTaskIds = new Set(orderedTaskIds);
                             tasks.forEach(task => {
                                 if (!currentViewTaskIds.has(task.id)) {
                                     reorderedTasks.push(task);
                                 }
                             });

                             // Check if the reordered list contains all original tasks
                             if (reorderedTasks.length === tasks.length) {
                                 tasks = reorderedTasks; // Update the main tasks array
                                 saveData('gtdTasks', tasks); // Save the new order
                                 // No immediate re-render needed, as the visual order is already correct.
                             } else {
                                 console.error("Task list length mismatch after sorting. Reverting.");
                                 render(); // Re-render to fix potential visual inconsistencies
                             }
                         }
                     });
                 } else {
                     // Hide drag handles if sorting is disabled for the current view
                     taskListUl.querySelectorAll('.task-item .drag-handle').forEach(handle => handle.style.display = 'none');
                 }
            };


            // --- Main Render Function ---
            // Updates the entire UI based on the current state (view, filters, data).
            const render = () => {
                console.log("Rendering view:", currentView);
                // Clear lists before re-rendering
                taskListUl.innerHTML = '';
                managementItemListUl.innerHTML = '';

                // Reset UI elements visibility
                taskListUl.classList.add('hidden');
                managementItemListUl.classList.add('hidden');
                addManagementItemForm.classList.add('hidden');
                addTaskForm.classList.remove('hidden'); // Show task form by default
                contextFilterContainer.classList.add('hidden'); // Hide filters by default
                projectFilterContainer.classList.add('hidden');
                emptyStateMessage.classList.add('hidden'); // Hide empty message initially

                let itemsToRender = []; // Array to hold tasks or management items for the current view
                let isManagementView = false;
                let baseTasks = []; // Holds tasks relevant to the view before filtering

                // --- Determine View and Filter/Sort Data ---
                switch (currentView) {
                    case 'inbox':
                        baseTasks = tasks.filter(t => t.status === 'inbox');
                        currentViewTitle.textContent = 'Inbox';
                        break;
                    case 'next':
                        baseTasks = tasks.filter(t => t.status === 'next' || t.status === 'project_task');
                        currentViewTitle.textContent = 'Next Actions';
                        contextFilterContainer.classList.remove('hidden'); // Show context filter
                        populateSelect(contextFilterSelect, contexts, 'All Contexts', 'all', true);
                        contextFilterSelect.value = currentContextFilter; // Set filter dropdown value
                        break;
                    case 'projects':
                        isManagementView = true;
                        currentManagementView = 'projects';
                        itemsToRender = projects;
                        currentViewTitle.textContent = 'Manage Projects';
                        break;
                    case 'waiting':
                        baseTasks = tasks.filter(t => t.status === 'waiting');
                        currentViewTitle.textContent = 'Waiting For';
                        break;
                    case 'scheduled':
                        // Sort scheduled tasks by due date (earliest first)
                        baseTasks = tasks.filter(t => t.status === 'scheduled').sort((a, b) => new Date(a.dueDate || 0) - new Date(b.dueDate || 0));
                        currentViewTitle.textContent = 'Scheduled';
                        break;
                    case 'someday':
                        baseTasks = tasks.filter(t => t.status === 'someday');
                        currentViewTitle.textContent = 'Someday/Maybe';
                        break;
                    case 'reference':
                        baseTasks = tasks.filter(t => t.status === 'reference');
                        currentViewTitle.textContent = 'Reference';
                        break;
                    case 'contexts':
                        isManagementView = true;
                        currentManagementView = 'contexts';
                        itemsToRender = contexts;
                        currentViewTitle.textContent = 'Manage Contexts';
                        break;
                    case 'areas':
                        isManagementView = true;
                        currentManagementView = 'areas';
                        itemsToRender = areas;
                        currentViewTitle.textContent = 'Manage Areas';
                        break;
                    case 'all-tasks':
                        baseTasks = tasks.filter(t => t.status !== 'completed'); // Exclude completed
                        currentViewTitle.textContent = 'All Tasks';
                        projectFilterContainer.classList.remove('hidden'); // Show project filter
                        populateSelect(projectFilterSelect, projects, 'All Projects', 'all', true);
                        projectFilterSelect.value = currentProjectFilter; // Set filter dropdown value
                        break;
                    // *** NEW: Completed View Case ***
                    case 'completed':
                        // Filter for completed tasks and sort by completion date (most recent first)
                        baseTasks = tasks.filter(t => t.status === 'completed')
                                        .sort((a, b) => new Date(b.completedAt || 0) - new Date(a.completedAt || 0));
                        currentViewTitle.textContent = 'Completed Tasks';
                        break;
                    default: // Fallback to inbox if view is unknown
                        currentView = 'inbox';
                        baseTasks = tasks.filter(t => t.status === 'inbox');
                        currentViewTitle.textContent = 'Inbox';
                }

                // Apply filters if it's a task view (not management)
                if (!isManagementView) {
                    itemsToRender = baseTasks; // Start with the base tasks for the view

                    // Apply context filter if in 'Next Actions' view
                    if (currentView === 'next' && currentContextFilter !== 'all') {
                        itemsToRender = itemsToRender.filter(task => task.contextId === currentContextFilter);
                    }
                    // Apply project filter if in 'All Tasks' view
                    if (currentView === 'all-tasks' && currentProjectFilter !== 'all') {
                        itemsToRender = itemsToRender.filter(task => task.projectId === currentProjectFilter);
                    }

                    // Maintain the user-defined sort order (from SortableJS) for applicable views
                    // Only re-sort if not already sorted by date (scheduled, completed)
                    if (!['scheduled', 'completed'].includes(currentView)) {
                         const taskOrderMap = new Map(tasks.map((task, index) => [task.id, index]));
                         itemsToRender.sort((a, b) => (taskOrderMap.get(a.id) ?? Infinity) - (taskOrderMap.get(b.id) ?? Infinity));
                    }
                }

                // --- Update Sidebar Active State ---
                sidebarLinks.forEach(link => {
                    link.classList.remove('active'); // Remove active class from all links
                    // Add active class to the link corresponding to the current view
                    if (link.id === `nav-${currentView}`) {
                        link.classList.add('active');
                    }
                });

                // --- Render Items ---
                if (isManagementView) {
                    // Show management list and add form, hide task list/form
                    managementItemListUl.classList.remove('hidden');
                    addTaskForm.classList.add('hidden');
                    addManagementItemForm.classList.remove('hidden');
                    newManagementItemNameInput.placeholder = `Add new ${currentManagementView.slice(0, -1)}...`; // Set placeholder dynamically

                    if (itemsToRender.length === 0) {
                        // Show empty state message for management views
                        emptyStateMessage.textContent = `No ${currentManagementView} defined yet.`;
                        emptyStateMessage.classList.remove('hidden');
                    } else {
                        // Sort management items alphabetically and render them
                        itemsToRender.sort((a, b) => a.name.localeCompare(b.name))
                                     .forEach(item => managementItemListUl.appendChild(renderManagementItem(item, currentManagementView.slice(0, -1))));
                    }
                } else { // Task View
                    // Show task list, hide management list/form
                    taskListUl.classList.remove('hidden');
                    if (itemsToRender.length === 0) {
                        // Show empty state message for task views
                        let emptyMsg = `No tasks in ${currentViewTitle.textContent}.`;
                        // Add context/project specific message if filter is active
                        if (currentView === 'next' && currentContextFilter !== 'all') emptyMsg += ` with the selected context.`;
                        if (currentView === 'all-tasks' && currentProjectFilter !== 'all') emptyMsg += ` for the selected project.`;
                        emptyStateMessage.textContent = emptyMsg;
                        emptyStateMessage.classList.remove('hidden');
                    } else {
                        // Render each task item
                        itemsToRender.forEach(task => {
                            const taskElement = renderTaskItem(task);
                            if (taskElement) { // Ensure element was created successfully
                                taskListUl.appendChild(taskElement);
                            }
                        });
                    }
                }

                // --- Initialize or Destroy SortableJS ---
                // Enable/disable sorting based on the current view
                initSortable();
            };


            // --- Modal Functions ---
            // Opens the task edit/process modal.
            const openModal = (taskId = null) => {
                // Ensure dropdowns exist
                if (!editTaskProject || !editTaskContext || !editTaskArea) {
                    console.error("Modal select elements not found!");
                    return;
                }
                // Populate dropdowns with current projects, contexts, areas
                populateSelect(editTaskProject, projects, 'None', '');
                populateSelect(editTaskContext, contexts, 'None', '');
                populateSelect(editTaskArea, areas, 'None', '');

                const task = getTaskById(taskId);
                if (!task) {
                    console.error("Task not found for modal:", taskId); return;
                }

                // Populate modal fields with task data
                modalTitle.textContent = 'Edit Task';
                editTaskId.value = task.id;
                editTaskTitle.value = task.title;
                editTaskNotes.value = task.notes || '';
                editTaskStatus.value = task.status;
                editTaskProject.value = task.projectId || '';
                editTaskContext.value = task.contextId || '';
                editTaskArea.value = task.areaId || '';
                editTaskDueDate.value = task.dueDate || '';
                deleteTaskButton.classList.remove('hidden'); // Show delete button
                // Assign the delete function directly to the button's click handler
                deleteTaskButton.onclick = () => deleteTask(taskId);

                taskModal.style.display = 'flex'; // Show the modal using flex for centering
            };

            // Closes the task edit modal and resets the form.
            const closeModal = () => {
                taskModal.style.display = 'none';
                editTaskForm.reset(); // Clear form fields
                editTaskId.value = '';
                deleteTaskButton.classList.add('hidden'); // Hide delete button
                deleteTaskButton.onclick = null; // Remove the specific delete handler
            };

            // --- Time Log Modal Functions ---
            // Renders a single time log entry (<li> element).
            const renderLogItem = (log, taskId) => {
                const li = document.createElement('li');
                li.className = 'log-item text-sm text-gray-700 py-1.5 px-2 border-b border-gray-100 flex justify-between items-center gap-2';
                li.dataset.logId = log.id; // Store log ID for deletion

                // Format date, duration, and description
                const logDate = log.startTime ? new Date(log.startTime).toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) : 'N/A';
                const durationText = formatDuration(log.duration || 0);
                const descriptionText = log.description || (log.manual ? 'Manual Entry' : 'Tracked Time');
                // Icon indicating manual vs timer entry
                const typeIcon = log.manual ? '<i class="fas fa-pencil-alt text-blue-500" title="Manual Entry"></i>' : '<i class="fas fa-stopwatch text-green-500" title="Timer Entry"></i>';

                // Construct inner HTML
                li.innerHTML = `
                    <div class="flex-grow flex items-center gap-2 overflow-hidden">
                        <span class="flex-shrink-0 w-5 text-center">${typeIcon}</span> <span class="font-medium w-16 flex-shrink-0">${logDate}</span> <span class="truncate" title="${descriptionText}">${descriptionText}</span> </div>
                    <div class="flex items-center gap-2 flex-shrink-0">
                        <span class="text-xs bg-gray-100 px-1.5 py-0.5 rounded">${durationText}</span> <button class="delete-log-button text-red-400 hover:text-red-600 px-1 py-0.5 rounded" title="Delete Log Entry">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                // Add event listener for the delete button
                li.querySelector('.delete-log-button').addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent triggering other clicks
                    if (confirm('Are you sure you want to delete this time log entry?')) {
                        deleteLog(taskId, log.id);
                    }
                });
                return li;
            };

            // Updates the content of the time log modal for a specific task.
            const renderTimeLogModal = (taskId) => {
                 const task = getTaskById(taskId);
                 if (!task) return; // Exit if task not found

                 timeLogTaskId.value = taskId; // Store task ID in hidden input
                 timeLogModalTitle.textContent = `Time Logs for: ${task.title}`; // Set modal title
                 timeLogListUl.innerHTML = ''; // Clear previous log entries

                 const logs = task.timeLogs || [];
                 const totalSeconds = calculateTotalTime(taskId);
                 const activeLog = getActiveLog(taskId); // Check if a timer is active for this task

                 // Update total time display, accounting for the *current* duration of an active timer
                 let displayTotalSeconds = totalSeconds;
                 if (activeLog) {
                     const currentDuration = Math.round((new Date().getTime() - new Date(activeLog.startTime).getTime()) / 1000);
                     // Adjust total: subtract the stored (likely 0) duration of the active log and add its current running duration
                     displayTotalSeconds = totalSeconds - (activeLog.duration || 0) + currentDuration;
                 }
                 totalLoggedTimeSpan.textContent = formatDuration(displayTotalSeconds);


                 // Display logs or "no logs" message
                 if (logs.length === 0) {
                     noLogsMessage.classList.remove('hidden');
                 } else {
                     noLogsMessage.classList.add('hidden');
                     // Sort logs by start time, descending (most recent first) and render them
                     logs.sort((a, b) => new Date(b.startTime || 0) - new Date(a.startTime || 0))
                         .forEach(log => timeLogListUl.appendChild(renderLogItem(log, taskId)));
                 }

                 // Update Start/Stop button visibility based on whether a timer is active
                 if (activeLog) {
                     startTimerButton.classList.add('hidden');
                     stopTimerButton.classList.remove('hidden');
                 } else {
                     startTimerButton.classList.remove('hidden');
                     stopTimerButton.classList.add('hidden');
                 }

                 // Reset the manual log entry form
                 addManualLogForm.reset();
                 // Set default date for manual entry to today
                 try { // Use try-catch for safety, although unlikely to fail here
                    manualLogDateInput.valueAsDate = new Date();
                 } catch (e) {
                     console.error("Error setting default date:", e);
                     // Fallback to setting YYYY-MM-DD string
                     const today = new Date();
                     const yyyy = today.getFullYear();
                     const mm = String(today.getMonth() + 1).padStart(2, '0');
                     const dd = String(today.getDate()).padStart(2, '0');
                     manualLogDateInput.value = `${yyyy}-${mm}-${dd}`;
                 }
            };

            // Opens the time log modal for a task.
            const openTimeLogModal = (taskId) => {
                renderTimeLogModal(taskId); // Populate modal with task data
                timeLogModal.style.display = 'flex'; // Show the modal
                // If this task's timer is the globally active one, start UI updates
                if (activeTimerTaskId === taskId && getActiveLog(taskId)) {
                    startActiveTimerUpdates(taskId);
                }
            };

            // Closes the time log modal.
            const closeTimeLogModal = () => {
                timeLogModal.style.display = 'none';
                timeLogTaskId.value = ''; // Clear the hidden task ID
                addManualLogForm.reset(); // Reset the manual entry form
                stopActiveTimerUpdates(); // Stop UI updates when modal closes, regardless of which task was active
            };


            // --- Import/Export Functions ---
            // Exports all application data to a JSON file.
            const exportData = () => {
                console.log("Exporting data...");
                // Ensure tasks have timeLogs array before exporting (migration/safety)
                 tasks.forEach(task => { if (!Array.isArray(task.timeLogs)) task.timeLogs = []; });

                // Structure the data for export
                const dataToExport = {
                    tasks: tasks,
                    projects: projects,
                    contexts: contexts,
                    areas: areas,
                    metadata: { // Include some metadata
                        exportedAt: new Date().toISOString(),
                        appName: "Zenith GTD",
                        version: "1.3" // Increment version for completed view feature
                    }
                };
                try {
                    // Convert data to JSON string
                    const jsonString = JSON.stringify(dataToExport, null, 2); // Pretty print JSON
                    // Create a Blob object
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    // Create a temporary URL for the Blob
                    const url = URL.createObjectURL(blob);
                    // Create a temporary anchor element for download
                    const a = document.createElement('a');
                    a.href = url;
                    const dateStr = new Date().toISOString().slice(0, 10); // Get YYYY-MM-DD
                    a.download = `zenith-gtd-backup-${dateStr}.json`; // Set filename
                    document.body.appendChild(a); // Add to DOM to make it clickable
                    a.click(); // Programmatically click the link to trigger download
                    document.body.removeChild(a); // Remove the temporary link
                    URL.revokeObjectURL(url); // Release the object URL
                    console.log("Data exported successfully.");
                } catch (error) {
                    console.error("Error exporting data:", error);
                    alert("An error occurred while exporting data.");
                }
            };

            // Imports data from a selected JSON file, overwriting existing data.
            const importData = (event) => {
                console.log("Import file selected...");
                const file = event.target.files[0]; // Get the selected file
                if (!file) { console.log("No file selected."); return; }
                // Validate file type
                if (file.type !== "application/json") {
                    alert("Invalid file type. Please select a '.json' file.");
                    event.target.value = null; // Reset file input
                    return;
                }

                const reader = new FileReader(); // Create a FileReader
                // Define what happens when the file is successfully read
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result); // Parse the JSON content

                        // Basic validation of the imported JSON structure
                        if (typeof importedData !== 'object' || importedData === null ||
                            !Array.isArray(importedData.tasks) ||
                            !Array.isArray(importedData.projects) ||
                            !Array.isArray(importedData.contexts) ||
                            !Array.isArray(importedData.areas)) {
                            throw new Error("Invalid JSON structure. Required arrays (tasks, projects, contexts, areas) missing or invalid.");
                        }

                        // Confirm overwrite with the user
                        if (confirm("Importing this file will OVERWRITE all current data (tasks, projects, contexts, areas, time logs). Are you sure?")) {
                            console.log("User confirmed import.");
                            // Assign imported data, ensuring defaults/IDs for potentially missing fields (migration)
                            tasks = (importedData.tasks || []).map(task => ({
                                ...task,
                                id: task.id || generateId(), // Ensure ID exists
                                timeLogs: (Array.isArray(task.timeLogs) ? task.timeLogs : []).map(log => ({ // Ensure timeLogs array and log IDs/isActive
                                    ...log,
                                    id: log.id || generateId(),
                                    isActive: typeof log.isActive === 'boolean' ? log.isActive : false // Default isActive to false if missing
                                }))
                            }));
                            projects = (importedData.projects || []).map(p => ({ ...p, id: p.id || generateId() })); // Ensure project IDs
                            contexts = (importedData.contexts || []).map(c => ({ ...c, id: c.id || generateId() })); // Ensure context IDs
                            areas = (importedData.areas || []).map(a => ({ ...a, id: a.id || generateId() })); // Ensure area IDs

                            // Save the newly imported data to localStorage
                            saveData('gtdTasks', tasks);
                            saveData('gtdProjects', projects);
                            saveData('gtdContexts', contexts);
                            saveData('gtdAreas', areas);

                            console.log("Data imported and saved.");
                            alert("Data imported successfully!");
                            // Reset state after import
                            currentView = 'inbox'; // Go back to inbox view
                            currentContextFilter = 'all'; currentProjectFilter = 'all'; // Reset filters
                            activeTimerTaskId = null; stopActiveTimerUpdates(); // Reset any active timer state
                            render(); // Re-render the UI with imported data
                        } else {
                            console.log("User cancelled import.");
                        }
                    } catch (error) {
                        console.error("Error importing data:", error);
                        alert(`Failed to import data: ${error.message}. Please ensure the file is a valid JSON backup from Zenith GTD.`);
                    } finally {
                        event.target.value = null; // Reset file input regardless of outcome
                    }
                };
                // Define error handling for file reading
                reader.onerror = (e) => {
                    console.error("Error reading file:", e);
                    alert("An error occurred reading the selected file.");
                    event.target.value = null; // Reset file input
                };
                // Start reading the file as text
                reader.readAsText(file);
            };


            // --- Mobile Menu Functions ---
            // Opens the sidebar on mobile screens.
            const openMobileSidebar = () => {
                if (sidebar && sidebarOverlay) {
                    sidebar.classList.add('mobile-visible'); // Slide sidebar in
                    sidebarOverlay.classList.add('visible'); // Show overlay
                    document.body.classList.add('overflow-hidden'); // Prevent body scroll
                }
            };
            // Closes the sidebar on mobile screens.
            const closeMobileSidebar = () => {
                if (sidebar && sidebarOverlay) {
                    sidebar.classList.remove('mobile-visible'); // Slide sidebar out
                    sidebarOverlay.classList.remove('visible'); // Hide overlay
                    document.body.classList.remove('overflow-hidden'); // Allow body scroll
                }
            };

            // --- Event Listeners Setup ---
            // Add Task Form Submission
            if (addTaskForm) addTaskForm.addEventListener('submit', (e) => { e.preventDefault(); if (newTaskTitleInput) addTask(newTaskTitleInput.value); });
            // Add Management Item Form Submission
            if (addManagementItemForm) addManagementItemForm.addEventListener('submit', (e) => { e.preventDefault(); if (newManagementItemNameInput) addManagementItem(newManagementItemNameInput.value); });
            // Edit Task Form Submission (Modal Save)
            if (editTaskForm) editTaskForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const id = editTaskId.value; if (!id) return; // Need task ID
                // Collect updated data from modal form
                const updates = {
                    title: editTaskTitle.value.trim(), notes: editTaskNotes.value.trim(), status: editTaskStatus.value,
                    projectId: editTaskProject.value || null, contextId: editTaskContext.value || null,
                    areaId: editTaskArea.value || null, dueDate: editTaskDueDate.value || null
                };
                // Validation: Project tasks must have a project selected
                if (updates.status === 'project_task' && !updates.projectId) { alert('Please select a project for a "Project Task".'); return; }
                updateTask(id, updates); // Update the task data
                closeModal(); // Close the modal
            });
            // Edit Task Modal Close/Cancel Buttons
            if (closeModalButton) closeModalButton.addEventListener('click', closeModal);
            if (cancelModalButton) cancelModalButton.addEventListener('click', closeModal);
            // Time Log Modal Close/Cancel Buttons
            if (timeLogModalCloseButton) timeLogModalCloseButton.addEventListener('click', closeTimeLogModal);
            if (timeLogModalCancelButton) timeLogModalCancelButton.addEventListener('click', closeTimeLogModal);
            // Click outside modals to close them
            window.addEventListener('click', (event) => { if (event.target === taskModal) closeModal(); if (event.target === timeLogModal) closeTimeLogModal(); });
            // Import/Export Buttons
            if (exportDataButton) exportDataButton.addEventListener('click', exportData);
            if (importDataInput) importDataInput.addEventListener('change', importData);
            // Sidebar Navigation Links
            sidebarLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault(); // Prevent default link behavior
                    const view = link.id.replace('nav-', ''); // Extract view name from link ID
                    if (view !== currentView) { // Only change view if it's different
                        currentView = view;
                        // Reset management view tracker if not a management link
                        if (!['projects', 'contexts', 'areas'].includes(view)) currentManagementView = null;
                        // Reset filters when changing main view
                        currentContextFilter = 'all'; currentProjectFilter = 'all';
                        render(); // Render the new view
                    }
                    // Close mobile sidebar if it's open after clicking a link
                    if (sidebar && sidebar.classList.contains('mobile-visible')) closeMobileSidebar();
                });
            });
            // Mobile Menu Toggle/Close Buttons
            if (menuToggleButton) menuToggleButton.addEventListener('click', (e) => { e.stopPropagation(); openMobileSidebar(); });
            if (sidebarCloseButton) sidebarCloseButton.addEventListener('click', closeMobileSidebar);
            if (sidebarOverlay) sidebarOverlay.addEventListener('click', closeMobileSidebar);
            // Filter Select Dropdowns
            if (contextFilterSelect) contextFilterSelect.addEventListener('change', (e) => { currentContextFilter = e.target.value; if (currentView === 'next') render(); }); // Re-render Next Actions on filter change
            if (projectFilterSelect) projectFilterSelect.addEventListener('change', (e) => { currentProjectFilter = e.target.value; if (currentView === 'all-tasks') render(); }); // Re-render All Tasks on filter change

            // Time Log Modal Buttons & Form
            if (startTimerButton) startTimerButton.addEventListener('click', () => { const taskId = timeLogTaskId.value; if (taskId) startTimer(taskId); });
            if (stopTimerButton) stopTimerButton.addEventListener('click', () => { const taskId = timeLogTaskId.value; if (taskId) stopTimer(taskId); });
            if (addManualLogForm) addManualLogForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const taskId = timeLogTaskId.value;
                const dateStr = manualLogDateInput.value;
                const durationStr = manualLogDurationInput.value;
                const description = manualLogDescriptionInput.value;
                // Attempt to add manual log; form is reset within renderTimeLogModal on success
                if (taskId) {
                    addManualLog(taskId, dateStr, durationStr, description);
                }
            });

             // --- Initial Setup ---
             // Check for any timer marked as 'isActive' on load (e.g., after browser crash).
             // This simple version doesn't automatically *restart* the timer UI updates,
             // but it ensures the global `activeTimerTaskId` is set if one is found,
             // so the UI updates *will* start if the user opens the time log modal for that task.
             const initiallyActiveTask = tasks.find(task => task.timeLogs?.some(log => log.isActive));
             if (initiallyActiveTask) {
                 console.log("Found potentially active timer on load for task:", initiallyActiveTask.id);
                 // Optional: Could automatically stop it here, or prompt the user.
                 // stopTimer(initiallyActiveTask.id, false); // Example: Stop it silently
                 activeTimerTaskId = initiallyActiveTask.id; // Set global tracker
             }
             render(); // Initial render of the application UI

        }); // End DOMContentLoaded listener
    </script>
</body>
</html>
